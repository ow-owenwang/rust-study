#  

## 一、标量类型（Scalar Types）

标量类型表示一个单一的值，主要包括：

### 1. 整型（Integer）

#### 类型列表：

* 有符号：`i8`, `i16`, `i32`, `i64`, `i128`, `isize`
* 无符号：`u8`, `u16`, `u32`, `u64`, `u128`, `usize`

#### 特点：

* `isize` 和 `usize` 取决于平台位数（32位或64位）。
* 默认整型为 `i32`。
* 可以使用字面量后缀指定类型：`42u8`, `100i64`
* 提供 checked、wrapping、overflowing 和 saturating 算法来处理溢出。

#### 应用场景：

* `u8`：处理字节（如图像、网络数据）。
* `usize`：与内存或索引相关（如数组索引、容量）。

---

### 2. 浮点型（Floating Point）

#### 类型：

* `f32`：32位浮点数
* `f64`：64位浮点数（默认）

#### 特点：

* 遵循 IEEE-754 标准。
* 支持 NaN、∞ 等特殊值。

#### 应用场景：

* 科学计算、游戏物理引擎、机器学习模型等需要小数精度的应用。

---

### 3. 布尔类型（Boolean）

#### 类型：

* `bool`：只有两个值：`true` 和 `false`

#### 特点：

* 通常用于条件判断、逻辑运算。

#### 应用场景：

* 控制流程：`if`, `while` 等。

---

### 4. 字符类型（Character）

#### 类型：

* `char`：4字节 Unicode 字符

#### 特点：

* 能表示任何 Unicode 字符，不只是 ASCII。
* 和 C/C++ 的 `char` 不同，更像是一个 Unicode 标量值。

#### 应用场景：

* 处理国际化文本、多语言支持、字符分类等。

---

## 二、复合类型（Compound Types）

### 1. 元组（Tuple）

```rust
let tup: (i32, f64, char) = (500, 6.4, 'x');
```

#### 特点：

* 可包含不同类型。
* 固定长度，访问通过解构或索引。
* 常用于函数返回多个值。

#### 应用场景：

* 函数多返回值、临时组合数据。

---

### 2. 数组（Array）

```rust
let arr: [i32; 5] = [1, 2, 3, 4, 5];
```

#### 特点：

* 所有元素类型相同。
* 固定长度，分配在栈上。
* 安全访问（超界时 panic）。

#### 应用场景：

* 小数据集合，性能要求高、大小固定的数据存储。

---

## 三、其他相关类型

### 1. 切片（Slice）

```rust
let slice = & arr[1..3];
```

#### 特点：

* 引用数组或字符串的一部分。
* 动态大小，运行时确定。

#### 应用场景：

* 子数组访问、不复制数据即可操作部分数据。

---

### 2. 字符串类型

* `&str`：字符串切片（借用）
* `String`：堆分配，可变、拥有所有权

#### 特点：

* `&str` 通常用于函数参数。
* `String` 用于需要变更、扩展字符串的场合。

#### 应用场景：

* `String`：动态构造字符串，如用户输入。
* `&str`：静态文本或只读引用。

---

## 总结表：

| 类型  | 举例               | 特点                 | 应用场景          |
|-----|------------------|--------------------|---------------|
| 整型  | `i32`, `u64`     | 有无符号、不同大小          | 索引、计数、内存地址处理等 |
| 浮点型 | `f32`, `f64`     | IEEE-754，支持小数      | 科学计算、物理模拟等    |
| 布尔型 | `bool`           | 仅 `true` 和 `false` | 逻辑判断          |
| 字符  | `char`           | Unicode 字符，4字节     | 多语言文本处理       |
| 元组  | `(i32, char)`    | 混合类型，固定长度          | 多返回值          |
| 数组  | `[i32; 5]`       | 同一类型，固定大小          | 小批量数据、静态集合    |
| 切片  | `&[i32]`         | 部分访问，不复制           | 操作数据子集        |
| 字符串 | `String`, `&str` | 可变或不可变字符串          | 文本处理、用户输入     |

## 发散操作

发散操作指的是一种不会正常结束（即不会返回）的操作，它们会导致函数或表达式永远不会产生值或继续执行之后的代码。这些操作的类型是 !
，即 never 类型。

发散操作常见的形式
| 发散操作 | 含义说明 |
| ------------------ | --------------------- |
| `panic!()`         | 程序立即中止，永远不会返回 |
| `loop {}`          | 无限循环，不会自然结束 |
| `process::exit()`  | 直接退出进程（严格说不是 `!`，但近似） |
| `unimplemented!()` | 程序崩溃，标记未实现代码 |
| `unreachable!()`   | 编译器认为这段代码永远不会被执行 |

“发散”这个词来自计算理论。我们可以简单理解为：

- 一个会终止的程序叫做收敛（converging）；
- 一个不会终止或不能产生值的程序叫做发散（diverging）。
  在 Rust 中，编译器能静态地识别哪些操作是“发散”的，这样可以在类型推导时使用 ! 类型占位。

发散操作在实际代码中的作用：

```rust
fn get_value(opt: Option<i32>) -> i32 {
    match opt {
        Some(v) => v,
        None => panic!("No value!"), // panic 是发散操作，类型为 `!`，能自动转换为 i32
    }
}

```

发散操作 = 一段永远不会返回或终止的代码，它的类型是 !，在 Rust 类型系统中起到了强大的控制流建模作用。