/*
在Rust中，`&str`、`String` 和字符串切片之间的关系和区别可以从它们的类型、存储方式、用途以及生命周期等方面来解释。

### 1. `&str`（字符串切片）

- **定义**：`&str` 是一种字符串切片（slice），它是对某个字符串数据的引用。通常称为“字符串切片”。
- **存储方式**：`&str` 是一个不可变的引用，指向某个地方的 UTF-8 编码的字符串数据。这个字符串数据可以存储在栈上（如字符串字面量），也可以存储在堆上（如 `String`）。
- **特点**：
  - `&str` 是一个视图，不拥有字符串数据，只是借用了字符串数据。
  - 字符串字面量（例如 `"hello"`）的类型就是 `&str`，存储在程序的二进制文件中，且在整个程序的生命周期中不可变。
  - 因为 `&str` 是不可变的，所以你不能改变它的内容。
  - 通常更轻量，因为它只是一个指针和长度（两者加起来是16字节）。
- **用途**：用于不需要所有权、只需对字符串进行只读操作的场景。

### 2. `String`

- **定义**：`String` 是 Rust 的堆分配（heap-allocated）字符串类型，表示一个可变、拥有所有权的字符串。
- **存储方式**：`String` 是一个堆分配的数据结构，它在堆上动态分配内存来存储其内容。它拥有字符串的数据并负责管理内存。
- **特点**：
  - `String` 是可变的，你可以对其内容进行修改。
  - 由于它是堆分配的，因此 `String` 的大小可以在运行时动态变化（即可以追加或减少字符）。
  - `String` 允许拥有所有权，意味着当 `String` 被转移（通过赋值或函数传递），它的所有权也会转移。
  - `String` 可以通过 `from` 方法或 `to_string()` 方法从 `&str` 创建。
- **用途**：用于需要可变字符串或需要拥有字符串所有权的场景。

### 3. 字符串切片

- **定义**：字符串切片是指通过切片操作获取的一部分字符串，它的类型也是 `&str`。
- **存储方式**：它是对现有字符串的一部分的引用，存储方式与 `&str` 相同，通常也存储在栈上或作为堆上数据的一部分。
- **特点**：
  - 它是对现有字符串的部分引用，因此不拥有数据。
  - 字符串切片可以在 `&str` 或 `String` 上进行，例如 `&my_string[0..5]`。
- **用途**：用于引用字符串的一部分，而不需要复制或拥有完整的字符串。

### 区别总结

1. **存储位置**：
   - `&str` 是对字符串数据的引用，数据可以存储在栈上或堆上，`&str` 本身是轻量的（指针+长度）。
   - `String` 是堆分配的字符串，数据存储在堆上。
   - 字符串切片 `&str` 是对现有字符串（无论是 `String` 还是 `&str`）的一部分的引用。

2. **可变性**：
   - `&str` 是不可变的，你无法改变它的内容。
   - `String` 是可变的，你可以追加、删除或修改其内容。

3. **所有权**：
   - `&str` 不拥有数据的所有权，只是借用数据。
   - `String` 拥有数据的所有权，当 `String` 被转移时，所有权也会转移。
   - 字符串切片 `&str` 也是不拥有数据所有权的。

4. **用途**：
   - 使用 `&str` 时，适合只读操作，不需要修改或拥有字符串的场景。
   - 使用 `String` 时，适合需要动态构建、修改字符串或者需要拥有字符串数据的场景。
   - 使用字符串切片时，适合从现有字符串中提取一部分数据，而不需要复制数据。



字符串字面量（string literal）和字符串切片（string slice）之间存在密切的关系，字符串字面量实际上是字符串切片的一种特殊形式。

### 字符串字面量

- **定义**：字符串字面量是在代码中直接编写的字符串，比如 `"hello"`。
- **类型**：字符串字面量的类型是 `&str`，即字符串切片。它是一个指向程序的只读内存区域（通常是静态存储区）的不可变引用。
- **存储**：字符串字面量的内容通常存储在程序的只读数据区中，并且在程序的整个生命周期中是不可变的。
- **生命周期**：因为字符串字面量在程序的整个生命周期中都是有效的，所以它的生命周期是 `'static`，即在整个程序运行期间都有效。

### 字符串切片

- **定义**：字符串切片是对现有字符串的一部分的引用。它的类型是 `&str`。
- **来源**：字符串切片可以来自 `String` 或其他 `&str` 类型，或是对它们进行切片操作得到的部分引用。
- **存储**：字符串切片引用的字符串数据可以存储在堆上（如果来自 `String`），也可以存储在静态存储区（如果来自字符串字面量）。
- **生命周期**：字符串切片的生命周期取决于它引用的字符串数据的生命周期。如果引用的是字符串字面量，它的生命周期也可以是 `'static`，如果引用的是 `String` 的一部分，它的生命周期与 `String` 的生命周期绑定。

### 字符串字面量和字符串切片的关系

- **类型关系**：字符串字面量是 `&str` 类型，所以它本质上就是一种字符串切片。所有的字符串字面量都是字符串切片，但不是所有的字符串切片都是字符串字面量。例如，从 `String` 中提取的切片也是 `&str` 类型，但它引用的不是字符串字面量，而是堆上的数据。

- **不可变性**：字符串字面量和字符串切片都是不可变的引用。你无法通过 `&str` 修改字符串内容，无论这个 `&str` 是字符串字面量还是来自 `String` 的切片。

- **存储位置**：字符串字面量存储在静态存储区（程序的只读内存中），而字符串切片可以引用堆上的数据或静态存储区中的数据。如果你对 `String` 进行了切片操作，那么这个切片指向的就是堆上的数据。
 */
fn main() {
    // &str 是一个字符串字面量，不可变
    let s1: &str = "hello";

    // String 是一个可变字符串，存储在堆上
    let mut s2 = String::from("hello");

    // 可以对 String 进行修改
    s2.push_str(", world");

    // 字符串切片，引用了 String 的一部分
    let s3: &str = &s2[0..5];

    println!("s1: {}", s1); // 输出: hello
    println!("s2: {}", s2); // 输出: hello, world
    println!("s3: {}", s3); // 输出: hello
}