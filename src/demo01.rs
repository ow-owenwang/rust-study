/*
Rust 中采用值比较而不是地址比较的设计背后有几个重要原因，这与 Rust 的核心设计理念、内存安全性和用户体验相关。让我们深入了解这一设计背后的原因。

### 1. **安全与一致性**
   - **内存安全**：Rust 是一个强调内存安全的系统编程语言。通过比较值而不是地址，Rust 可以确保程序的行为更加一致和可预测。例如，当两个动态数组的内容相同时，程序员通常期望它们被认为是相等的，而不必关心它们是否位于内存中的同一位置。这种行为在许多情况下能减少潜在的错误。

   - **所有权与借用系统**：Rust 的所有权和借用系统非常复杂。如果 Rust 采用地址比较，可能会导致很多未定义行为或逻辑错误，因为在 Rust 中，所有权的转移或引用的生命周期非常关键。值比较确保了当数据被移动或复制时，程序的行为仍然是正确的。

### 2. **直观性与用户体验**
   - **用户期望**：在大多数应用场景下，程序员会希望比较两个容器的数据是否相等，而不是比较它们的内存地址。例如，当你比较两个数组或向量时，用户通常希望的是它们的内容是否相同，而不是它们是否在同一内存位置。这种设计符合大多数程序员的直觉和期望，从而减少了出错的概率。

   - **减少陷阱**：如果 Rust 默认使用地址比较，会给开发者带来很多容易忽略的陷阱。例如，在堆上分配的两个相同值的 `Vec` 会因为它们的地址不同而被认为不相等，这可能会导致开发者困惑，尤其是在处理复杂数据结构时。Rust 的值比较设计减少了这种困惑，使代码更加直观。

### 3. **泛型和一致性**
   - **泛型编程**：Rust 强调泛型编程，允许开发者编写通用的代码。在泛型上下文中，值比较的行为更加一致。例如，`Vec<T>` 的值比较行为与其他容器类型（如 `String`、`HashMap` 等）的比较方式保持一致。这种一致性使得泛型代码在不同数据类型之间更容易理解和使用。

### 4. **与其他语言的比较**
   - **其他语言**：虽然很多语言默认使用地址比较，但它们通常提供机制让开发者可以进行值比较。例如，C++ 中可以重载 `operator==` 来实现值比较，Java 和 Python 则有 `equals()` 和 `__eq__()` 方法来进行值比较。然而，这种方式往往要求开发者显式定义或调用值比较函数，增加了额外的工作量和可能的错误。

   - **Rust 的区别**：Rust 在设计时选择了不同的默认行为，确保程序的安全性和直观性。这种设计决策虽然不同于许多传统语言，但它符合 Rust 对内存安全和并发安全的追求，同时也简化了开发者的工作。

### 总结
Rust 中默认采用值比较而不是地址比较，是为了确保内存安全、简化开发者的工作、减少陷阱以及提供更一致的泛型编程体验。这种设计虽然与某些传统语言有所不同，但它符合 Rust 的核心理念，帮助开发者编写更安全、更可靠的代码。
 */

fn main() {
    // 动态数组 Vec 会存储在堆上，但 v 本身是一个栈上变量，包含了指向堆上数据的指针、长度和容量信息。
    let v = vec![0; 3]; // 默认值为 0，初始长度为 3
    let v_from = Vec::from([0, 0, 0]);
    assert_eq!(v, v_from); // assert_eq!() 是值比较，不是引用地址比较
}