/*
违反了 Rust 的借用规则（Borrowing rules）：在某一作用域内，同时只能有一个可变引用，或者任意多个不可变引用，但不可混用。


let first = &v[0];
这行代码对 v 的第一个元素创建了一个不可变引用 first。

v.push(6);
这行代码尝试对 v 进行修改（即可变借用），但在此时 v 仍然被 first 不可变借用了。

触发编译错误：
Rust 编译器此时报错，因为你在 v 仍被不可变引用的同时，试图对它进行可变借用，这是不允许的。


如果 Rust 允许，这种操作。Vec 的 push 方法可能会导致底层内存重新分配（reallocate），如果此时仍然保留原来的元素引用 &v[0]，就会导致悬垂引用（dangling reference）！
Rust 的借用检查器正是为了防止这种 内存安全隐患。
 */

fn main() {
    let mut v = vec![1, 2, 3, 4, 5];

    // 先借用，再修改，报错
    //---------------------------
    // let first = &v[0];
    // v.push(6);
    //---------------------------

    // 1.延迟引用，避免冲突
    //---------------------------
    v.push(6); // 先修改
    let first = &v[0]; // 再创建引用
    //---------------------------

    // 2.直接使用索引或值拷贝（避免借用）
    //---------------------------
    // let first = v[0]; // 复制值，而不是借用引用
    // v.push(6); // 不冲突
    //---------------------------

    println!("first = {}", first); // first = 1
}
